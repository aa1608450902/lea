%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "lang/grammar.h"
void yyerror(const char* s);
extern int yylex(void);
extern int yyparse(void);
char lea_file[128];
int is_invoke = -1;
int args_open = -1;
int nest_deep = 0;
char var_name[128];
%}

%union {
    char* ycText;
    char* ycType;
    int ycValueInt;
    double ycValueDouble;
    unsigned short ycValueBool;
    char ycValueChar;
    char* ycOther;
}

%token KW_EOF
%token COMMENT_SINGLE COMMENT_BEGIN COMMENT_END
%token KW_BYTE
%token KW_CHAR
%token KW_STRING
%token KW_INT
%token KW_DOUBLE
%token KW_BOOL
%token <ycBool> KW_TRUE
%token <ycBool> KW_FALSE
%token KW_IF KW_ELSE KW_FOR KW_WHILE KW_MATCH KW_CASE KW__ KW_CLASS KW_STRUCT
%token <ycText> KW_DEF
%token <ycText> KW_RETURN
%token AND OR NOT EQ NE GT GE LT LE
%token ARROW ASSIGN LPAREN RPAREN DOT COMMA SEMI NEWLINE BLOCK_BEGIN BLOCK_END
%token <ycText> COLON
%token <ycValueDouble> DOUBLE
%token <ycValueInt> INTEGER
%token <ycText> FIELD
%token <ycValueChar> CHAR
%token <ycText> STRING
%token OP_ADD OP_SUB OP_MUL OP_DIV OP_MOD

%type <ycText> variableName
%type <ycText> leaVar
//%type <ycText> leaVal
//%type <ycText> booExp
//%type <ycText> booAtom
//%type <ycText> calExp
//%type <ycText> calExpPro
//%type <ycText> calExpAtom
//%type <ycText> leaNum

%start root

%%

root: {_lea(lea_file);} statement;

statement:
  KW_EOF {printf("Grammar parsed success.\n"); complete(); exit(0);}
| ending {printf("[y] ending\n");} statement
| commentDefine {printf("[y] comment\n");} statement
| variableDefine {printf("[y] variableDefine\n");} statement
| variableAssign {printf("[y] variableAssign\n");} statement
| invokeDefine {printf("[y] invokeDefine\n");} statement
| functionDefine {printf("[y] functionDefine\n");} statement
| stateIfDefine {printf("[y] stateIfDefine\n");} statement
| stateForDefine {printf("[y] stateForDefine\n");} statement
| stateMatchDefine {printf("[y] stateMatchDefine\n");} statement
| {_scope_ano(lea_line);} codeBlockDefine {_scope_end(NULL);} statement
;


baseInput: COMMENT_SINGLE|KW_BYTE|KW_CHAR|KW_STRING|KW_INT|KW_DOUBLE|KW_BOOL|
KW_TRUE|KW_FALSE|KW_IF|KW_ELSE|KW_FOR|KW_WHILE|KW_MATCH|KW_CASE|KW_DEF|KW__|KW_STRUCT|KW_CLASS|KW_RETURN|
AND|OR|NOT|EQ|NE|GT|GE|LT|LE|
ARROW|ASSIGN|LPAREN|RPAREN|DOT|COMMA|SEMI|COLON|BLOCK_BEGIN|BLOCK_END|
DOUBLE|INTEGER|FIELD|CHAR|STRING|
OP_ADD|OP_SUB|OP_MUL|OP_DIV|OP_MOD;

// --------------------------------------------
// define comment
// --------------------------------------------
commentDefine: sc | mc;
sc: COMMENT_SINGLE singleComment;
mc: COMMENT_BEGIN {_open_mc();} multiComment;
singleComment: baseInput singleComment | NEWLINE    {_p_yacc("-multiComment-end\n");}
;
multiComment: baseInput2 multiComment | COMMENT_END {_close_mc();_p_yacc("-multiComment-end\n");}
;
baseInput2: baseInput | COMMENT_BEGIN | NEWLINE;
// --------------------------------------------

// --------------------------------------------
// define variable
// --------------------------------------------
variableDefine: variableName COLON basicType   {_var_def($2);};
variableAssign:
  variableName COLON basicType ASSIGN leaVal   {_var_def_ass($1);_p_yacc("-assign-type\n");}
| variableName ASSIGN leaVal                   {_var_ass($1);_p_yacc("-assign\n");}
;
variableName: FIELD                            {$$ = $1; _push($1);};
// --------------------------------------------

// --------------------------------------------
// define function
// --------------------------------------------
functionDefine: KW_DEF FIELD {_scope_begin($2); _def($2);} functionOptions {_scope_end(NULL);};
functionOptions:
  functionBody                                  {_p_yacc("-{}\n");}
| COLON returnType functionBody                 {_p_yacc("-type-{}\n");}
| lparen argsList functionBody                  {_p_yacc("-()-{}\n");}
| lparen argsList COLON returnType functionBody {_p_yacc("-()-type-{}\n");}
;
lparen: LPAREN;
argsList: RPAREN | FIELD COLON basicType argsLoop;
argsLoop: COMMA FIELD COLON basicType argsList | RPAREN;
returnType: basicType;
functionBody: ARROW leaVal {_p_yacc("-lambda\n");} | codeBlockDefine;
// --------------------------------------------

// --------------------------------------------
// define function invoke
// --------------------------------------------
invokeDefine: {nest_deep = 0;} variableName LPAREN invokeArgsList;
invokeArgsList: invokeArgsLoop | {_add_arg();} leaVal invokeArgsLoop;
invokeArgsLoop: {_add_arg();} COMMA leaVal invokeArgsList | RPAREN {_call(1);};
// --------------------------------------------

// --------------------------------------------
// define if-else if-else
// --------------------------------------------
stateIfDefine: stateIf stateElse;
stateIf: KW_IF {_scope_begin("if");} LPAREN leaVal RPAREN codeBlockDefine {_scope_end("if"); _if(); _p_yacc("-if\n");}
;
stateElse: ending | stateElseApp;
stateElseApp: ending | KW_ELSE stateElseLoop;
stateElseLoop:
  {_p_yacc("-elif\n"); _scope_begin("elif");} KW_IF LPAREN leaVal RPAREN codeBlockDefine {_scope_end("elif"); _elif();} stateElseApp
| {_p_yacc("-else\n"); _scope_begin("else");} codeBlockDefine {_scope_end("else"); _else();}
;
// --------------------------------------------

// --------------------------------------------
// define for-loop
// --------------------------------------------
stateForDefine: KW_FOR LPAREN stateForInit stateForCondition stateForUpdate {_scope_begin("for"); _for();} codeBlockDefine {_scope_end("for");}
;
stateForInit: SEMI | variableAssign SEMI;
stateForCondition: SEMI | leaVal SEMI;
stateForUpdate: RPAREN | variableAssign RPAREN;
// --------------------------------------------

// --------------------------------------------
// define match-case
// --------------------------------------------
stateMatchDefine: variableName KW_MATCH {_match();} stateMatchBlock;
stateMatchBlock: BLOCK_BEGIN stateCase;
stateCase:
  wordCase KW__ {_case();} ARROW stateCaseTail stateCaseLoop
| wordCase basicType {_case();} ARROW stateCaseTail stateCaseLoop
| wordCase leaVal {_case();} ARROW stateCaseTail stateCaseLoop
| ending stateCaseLoop
;
stateCaseLoop: stateCase | BLOCK_END;
wordCase: KW_CASE;
stateCaseTail: {_scope_begin("case");} codeBlockDefine {_scope_end("case");} | leaVal ending;
// --------------------------------------------

// --------------------------------------------
// define code block
// --------------------------------------------
codeBlockDefine: BLOCK_BEGIN {_block();} codeBlockLoop;
codeBlockLoop:
  ending codeBlockLoop
| variableDefine codeBlockLoop
| variableAssign codeBlockLoop
| invokeDefine codeBlockLoop
| commentDefine codeBlockLoop
| stateIfDefine codeBlockLoop
| stateForDefine codeBlockLoop
| stateMatchDefine statement
| {_scope_ano(lea_line);} codeBlockDefine {_scope_end(NULL);} codeBlockLoop
| BLOCK_END                                     {_block_();_p_yacc("-block-end\n");}
;
// --------------------------------------------


// --------------------------------------------
// define right value of variable and function return
// --------------------------------------------
// represent variable/function-invoking
leaVai:
  leaVar {rv_arg_add(var_name, "var");}
| leaVar LPAREN {rv_arg_add(var_name, "invoke");} leaInv {};
leaVar: FIELD {strcpy(var_name, $1);};
leaInv: RPAREN {printf("void nest: %d\n", nest_deep);} | leaInvOptions; // args list
leaInvOptions: booExp leaInvLoop; // args list
leaInvLoop: COMMA leaInvOptions | RPAREN {printf("nest: %d\n", nest_deep);};
// --------------------------------------------

// --------------------------------------------
// define bool expression
// --------------------------------------------
leaVal: {rv_enter();} booExp {rv_boo(); rv_exit();};
booExp:
  booExpNot
| booExp AND booExpNot
| booExp OR  booExpNot
;
//booExp:
//  booAtom {} booExpApp
//| booExpNot
//;
//booExpApp: {} booOps booAtom booExpApp | {} nothing;
//booOps: AND {rv_arg_add("&&", "&&");} |OR {rv_arg_add("||", "||");} ;
booExpNot:
  booAtom
| NOT booAtom
;
booAtom: // Don't use! inner implement!
  calExp
| calExp LT calExp {rv_boo_ops("<");}
| calExp GT calExp {rv_boo_ops(">");}
| calExp LE calExp {rv_boo_ops("<=");}
| calExp GE calExp {rv_boo_ops(">=");}
| calExp EQ calExp {rv_boo_ops("==");}
| calExp NE calExp {rv_boo_ops("!=");}
| booBas
;
// --------------------------------------------

// --------------------------------------------
// define calculation expression
// --------------------------------------------
calExp:
  calExpPro
| calExp OP_ADD calExpPro
| calExp OP_SUB calExpPro;
//calExp: calExpPro {n_com=0;n_com++;} calExpApp;
//calExpApp: calOpsCom {n_com++;} calExpPro calExpApp | nothing {rv_cal_com();};
//calExpApp: calOpsCom {n_com++;} calExpPro calExpApp | nothing {rv_cal_com();};
//calOpsCom: OP_ADD {rv_arg_add("+", "+");} | OP_SUB {rv_arg_add("-", "-");};

calExpPro:
  calExpAtom
| calExpPro OP_MUL calExpAtom
| calExpPro OP_DIV calExpAtom
;
//calExpPro: calExpAtom {n_pro=0;n_pro++;} calExpProApp;
//calExpPro: calExpAtom {n_pro=0;n_pro++;} calExpProApp;
//calExpProApp: calOpsPro {n_pro++;} calExpAtom calExpApp | nothing {rv_cal_pro();};
//calOpsPro: OP_MUL {rv_arg_add("*", "*");} | OP_DIV {rv_arg_add("/", "/");};

calExpAtom: // Don't use! inner implement!
  leaNum
| CHAR {char s[2]; sprintf(s, "%c", $1); rv_arg_add(s, "char");}
| STRING {_add_arg_str($1); rv_arg_add($1, "string");}
| LPAREN {add_deep(); rv_arg_add("(", "(");} booExp {rv_boo();rv_arg_add(")", ")");} RPAREN // solve "(" matching and loop back to the top level
| {nest_deep++; } leaVai {}
;
// --------------------------------------------

// --------------------------------------------
// common definition
// --------------------------------------------
leaBas:
  CHAR           {char s[2]; sprintf(s, "%c", $1); rv_arg_add(s, "char");}
| op_sub INTEGER {char s[20]; sprintf(s, "-%d", $2); rv_arg_add(s, "-int");}
| INTEGER        {char s[20]; sprintf(s, "%d", $1); rv_arg_add(s, "int");}
| op_sub DOUBLE  {char s[20]; sprintf(s, "-%f", $2); rv_arg_add(s, "-double");}
| DOUBLE         {char s[20]; sprintf(s, "%f", $1); rv_arg_add(s, "double");}
| STRING         {rv_arg_add($1, "string");}
| booBas
; // specific value
op_sub: OP_SUB;
leaNum:
  op_sub INTEGER {char s[20]; sprintf(s, "-%d", $2); rv_arg_add(s, "-int");}
| INTEGER        {char s[20]; sprintf(s, "%d", $1); rv_arg_add(s, "int");}
| DOUBLE         {char s[20]; sprintf(s, "%f", $1); rv_arg_add(s, "double");}
| op_sub DOUBLE  {char s[20]; sprintf(s, "-%f", $2); rv_arg_add(s, "-double");}
;
booBas: KW_TRUE  {rv_arg_add("true", "bool");} | KW_FALSE {rv_arg_add("false", "bool");};
basicType: KW_BYTE | KW_CHAR | KW_INT | KW_BOOL | KW_DOUBLE | KW_STRING;
ending: SEMI | NEWLINE;
//nothing: {printf("==nothing\n");};
// --------------------------------------------

%%

void yyerror(const char* s)
{
    printf("Grammar error : %s\n", s);
}